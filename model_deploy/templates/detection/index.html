{% load compress %} {% load static %}

<!DOCTYPE html>
<html>
  <head>
    <title>Face Recognition Camera Feed</title>
    <style>
      #loading {
        display: none;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        font-weight: bold;
        color: #000;
      }
      #canvas_output {
        display: block;
      }
    </style>
    <script
      async
      src="{% static 'js/opencv.js' %}"
      onload="openCvReady();"
    ></script>
    <script src="{% static 'js/utils.js' %}"></script>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    {% compress css %}
    <link rel="stylesheet" href="{% static 'src/output.css' %}" />
    {% endcompress %}
  </head>
  <body>
    {% csrf_token %}
    <div id="loading">Loading...</div>
    <div
      class="bg-primary w-full h-full pb-10 flex justify-center items-center"
    >
      <div
        class="bg-primary p-12 flex justify-center items-center min-h-screen"
      >
        <div
          class="w-4/5 lg:w-customFrame bg-white text-black rounded-3xl shadow-lg flex flex-col items-center py-5"
        >
          <img
            src="{% static 'assets/logo-bi.svg' %}"
            alt="logo"
            class="mb-4 w-32"
          />
          <h1 class="text-black text-center mb-4" style="font-size: 32px">
            BI - Presence
          </h1>
          <div class="grid justify-items-center" style="width: max-content">
            <div
              class="flex items-center justify-center bg-white border-4 rounded-lg border-primary w-full md:max-w-5xl h-fit"
            >
              <video
                id="cam_input"
                height="480"
                width="640"
                style="display: none"
              ></video>
              <canvas id="canvas_output" width="640" height="480"></canvas>
              <!-- Temporary canvas for face image conversion -->
              <canvas id="tempCanvas" style="display: none"></canvas>
            </div>
            <div id="result" class="text-black text-center mt-4"></div>
          </div>
        </div>
      </div>
    </div>

    <script type="text/JavaScript">
      function openCvReady() {
        cv['onRuntimeInitialized'] = () => {
          let video = document.getElementById("cam_input");
          navigator.mediaDevices.getUserMedia({ video: true, audio: false })
            .then(function (stream) {
              video.srcObject = stream;
              video.play();
            })
            .catch(function (err) {
              console.log("An error occurred! " + err);
            });

          let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
          let dst = new cv.Mat(video.height, video.width, cv.CV_8UC4);
          let gray = new cv.Mat();
          let cap = new cv.VideoCapture(video);
          let faces = new cv.RectVector();
          let classifier = new cv.CascadeClassifier();
          let utils = new Utils('errorMessage');

          function loadCascadeFile() {
            let faceCascadeFile = "{% static 'classifier/haarcascade_frontalface_default.xml' %}";
            fetch(faceCascadeFile)
              .then(response => response.arrayBuffer())
              .then(arrayBuffer => {
                let data = new Uint8Array(arrayBuffer);
                cv.FS_createDataFile('/', 'haarcascade_frontalface_default.xml', data, true, false);
                classifier.load('/haarcascade_frontalface_default.xml');
              })
              .catch(err => console.error('Failed to load cascade file:', err));
          }

          loadCascadeFile();

          const FPS = 30;
          const blueColor = [1, 86, 153, 255];

          async function classifyFace(face) {
            let faceBlob = await new Promise((resolve) => {
                cv.imshow('tempCanvas', face);
                document.getElementById('tempCanvas').toBlob(resolve, 'image/jpeg');
            });

            let formData = new FormData();
            formData.append('media', faceBlob, 'face.jpg');

            const response = await fetch("{% url 'classify-face' %}", {
                method: 'POST',
                body: formData,
                headers: {
                  'X-CSRFToken': '{{ csrf_token }}'
                }
            });

            const result = await response.json();
            return result;
          }

          async function processVideo() {
            let begin = Date.now();
            cap.read(src);
            src.copyTo(dst);
            cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY, 0);

            try {
              classifier.detectMultiScale(gray, faces, 1.3, 4, 0);
            } catch (err) {
              console.log(err);
            }

            for (let i = 0; i < faces.size(); ++i) {
              let face = faces.get(i);
              let faceImg = dst.roi(face);
              let result = await classifyFace(faceImg);

              if (result) {
                let point1 = new cv.Point(face.x, face.y);
                let point2 = new cv.Point(face.x + face.width, face.y + face.height);
                cv.rectangle(dst, point1, point2, blueColor);

                let confidence = result.confidence;
                let fullName = result.response && result.response.fullName ? result.response.fullName : "Something Went Wrong!";
                let text = `Name: ${fullName}, Conf: ${confidence.toFixed(2)}`;

                let ctx = document.getElementById('canvas_output').getContext('2d');
                ctx.font = '100% Arial';
                let textSize = ctx.measureText(text);

                cv.rectangle(dst, new cv.Point(face.x, face.y - 20), new cv.Point(face.x + textSize.width, face.y), blueColor, cv.FILLED);
                cv.putText(dst, text, new cv.Point(face.x, face.y - 5), cv.FONT_HERSHEY_SIMPLEX, 0.4, [255, 255, 255, 255], 1);
              }
            }
            cv.imshow("canvas_output", dst);
            let delay = Math.max(1000 / FPS - (Date.now() - begin), 0);
            setTimeout(processVideo, delay);
          }
          setTimeout(processVideo, 0);
        };
      }
    </script>
  </body>
</html>
